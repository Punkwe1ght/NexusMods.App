using System.Text;
using Microsoft.Extensions.Logging;
using Mutagen.Bethesda.Plugins;
using NexusMods.Abstractions.Loadouts;
using NexusMods.Abstractions.Loadouts.Sorting;
using NexusMods.Abstractions.Loadouts.Synchronizers;
using NexusMods.Abstractions.Loadouts.Synchronizers.Rules;
using NexusMods.Games.CreationEngine.Abstractions;
using NexusMods.Hashing.xxHash3;
using NexusMods.MnemonicDB.Abstractions;
using NexusMods.Paths;
using NexusMods.Sdk.FileStore;
using NexusMods.Sdk.Games;
using NexusMods.Sdk.Loadouts;

namespace NexusMods.Games.CreationEngine;

public class PluginsFile : IIntrinsicFile
{
    private readonly ICreationEngineGame _game;
    private readonly ISorter _sorter;
    private readonly ILogger<PluginsFile> _logger;
    private readonly Func<LoadoutId, IReadOnlyList<string>?>? _pluginOrderProvider;

    private record struct Metadata(RelativePath FileName, ModKey ModKey, Hash Hash, IPluginInfo Plugin);

    public PluginsFile(ILogger<PluginsFile> logger, ICreationEngineGame game, ISorter sorter,
        Func<LoadoutId, IReadOnlyList<string>?>? pluginOrderProvider = null)
    {
        _game = game;
        _sorter = sorter;
        Path = game.PluginsFile;
        _logger = logger;
        _pluginOrderProvider = pluginOrderProvider;
    }

    public GamePath Path { get; }

    public async Task Write(Stream stream, Loadout.ReadOnly loadout, Dictionary<GamePath, SyncNode> syncTree)
    {
        var plugins = await syncTree
            .Where(p => p.Key.Parent == KnownPaths.Data && KnownCEExtensions.PluginFiles.Contains(p.Key.Extension))
            .Where(p => p.Value.HaveLoadout)
            .ToAsyncEnumerable()
            .SelectAwait(MakeMetadata)
            .ToDictionaryAsync(x => x.ModKey);

        if (plugins.Count == 0)
            return;

        List<Metadata> sorted;
        var pluginOrder = _pluginOrderProvider?.Invoke(loadout.LoadoutId);
        if (pluginOrder is { Count: > 0 })
        {
            var orderMap = pluginOrder
                .Select((name, idx) => (name, idx))
                .ToDictionary(x => x.name, x => x.idx, StringComparer.OrdinalIgnoreCase);

            var supportsEsl = _game.SupportsEsl;
            sorted = plugins.Values
                .OrderBy(p => orderMap.TryGetValue(p.FileName.ToString(), out var idx) ? idx : int.MaxValue)
                .ThenBy(p => p.FileName.ToString(), StringComparer.OrdinalIgnoreCase)
                .ToList();
        }
        else
        {
            var supportsEsl = _game.SupportsEsl;
            sorted = _sorter.Sort(plugins.Values.ToList(), IdSelector, plugin => RuleCreator(plugin, plugins, supportsEsl))
                .ToList();
        }

        _logger.LogDebug("Sorted {Count} plugin files", sorted.Count);

        await using var sw = new StreamWriter(stream, leaveOpen: true);
        await sw.WriteLineAsync("# Generated by Nexus Mods App");

        foreach (var plugin in sorted)
        {
            await sw.WriteLineAsync($"*{plugin.FileName}");
        }

        await sw.FlushAsync();
    }

    private static IReadOnlyList<ISortRule<Metadata, ModKey>> RuleCreator(Metadata metadata, Dictionary<ModKey, Metadata> allPlugins, bool supportsEsl)
    {
        var resultList = new List<ISortRule<Metadata, ModKey>>();
        foreach (var master in metadata.Plugin.Masters)
        {
            // Skip missing masters here, we'll catch that in diagnostics
            if (!allPlugins.ContainsKey(master))
                continue;

            resultList.Add(new After<Metadata, ModKey>()
            {
                Other = master,
            });
        }

        // ESLs should come after ESMs (only for games that support ESL)
        if (supportsEsl && metadata.FileName.Extension == KnownCEExtensions.ESL)
        {
            foreach (var other in allPlugins.Values)
            {
                if (other.FileName.Extension == KnownCEExtensions.ESM)
                    resultList.Add(new After<Metadata, ModKey>()
                    {
                        Other = other.ModKey,
                    });
            }
        }

        // ESPs should come after ESMs (and ESLs if the game supports them)
        if (metadata.FileName.Extension == KnownCEExtensions.ESP)
        {
            foreach (var other in allPlugins.Values)
            {
                if (other.FileName.Extension == KnownCEExtensions.ESM ||
                    (supportsEsl && other.FileName.Extension == KnownCEExtensions.ESL))
                    resultList.Add(new After<Metadata, ModKey>()
                    {
                        Other = other.ModKey,
                    });
            }
        }

        return resultList;
    }

    private static ModKey IdSelector(Metadata metadata)
    {
        return metadata.ModKey;
    }

    private async ValueTask<Metadata> MakeMetadata(KeyValuePair<GamePath, SyncNode> arg)
    {
        var relPath = arg.Key.Path.FileName;
        Hash hash;

        // We need to figure out if we should look at the loadout or the disk
        var syncNode = arg.Value;
        if (syncNode.Actions.HasFlag(Actions.ExtractToDisk) || syncNode.Disk.Hash == Hash.Zero || syncNode.SourceItemType == LoadoutSourceItemType.Game)
            hash = syncNode.Loadout.Hash;
        else
            hash = syncNode.Disk.Hash;

        var pluginInfo = await _game.ParsePlugin(hash, relPath);
        return new Metadata(relPath, pluginInfo!.ModKey, hash, pluginInfo);
    }



    public Task Ingest(Stream stream, Loadout.ReadOnly loadout, Dictionary<GamePath, SyncNode> syncTree, ITransaction tx)
    {
        // TODO: Implement once we have sorting
        return Task.CompletedTask;
    }
}
